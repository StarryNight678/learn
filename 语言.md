# C++语言

引用字符串,首字母不需要大写.
`#include<string>`

## 申请和释放数组

[浅谈 C++ 中的 new/delete 和 new[]/delete[]](http://www.cnblogs.com/hazir/p/new_and_delete.html)
```
int *pia = new int[10];   
delete [] pia;
```

```
typedef struct SeqList
{	
	DataType *elem; /* 存储元素连续空间的地址*/
	int  length;	/* 表中元素的个数*/
	int  size;	/* 表的大小 */
}SeqList, *PSeqList;


struct  Node 		/* 单链表结点结构 */
{ 
	int	info;
	struct Node  	*next;
};
typedef struct Node  Node, *PNode;

```


## 容器使用

1. array
1. deque  双向队列
1. forward_list
1. list
1. map
1. queue
1. set
1. stack
1. unordered_map
1. unordered_set
1. vector


区别比较
List封装了链表,Vector封装了数组, list和vector得最主要的区别在于vector使用连续内存存储的，他支持[]运算符，而list是以链表形式实现的，不支持[]

Map,Set属于标准关联容器，使用了非常高效的平衡检索二叉树：红黑树，他的插入删除效率比其他序列容器高是因为不需要做内存拷贝和内存移动，而直接替换指向节点的指针即可。

Set和Vector的区别在于**Set不包含重复的数据**。Set和Map的区别在于Set只含有Key，而Map有一个Key和Key所对应的Value两个元素。
Map和Hash_Map的区别是Hash_Map使用了Hash算法来加快查找过程，但是需要更多的内存来存放这些Hash桶元素，因此可以算得上是采用空间来换取时间策略。



```
#include<stack>
#include<queue>
#include <vector>  

//定义
stack<int> st;
queue<int>  qu;
vector<int>  vec;

//栈
s.empty()               如果栈为空返回true，否则返回false  
s.size()                返回栈中元素的个数  
s.top()                 返回栈顶的元素，但不删除该元素 
s.pop()                 删除栈顶元素但不返回其值   
s.push()                在栈顶压入新元素  

//队列
q.empty()               如果队列为空返回true，否则返回false  
q.size()                返回队列中元素的个数
q.back()                返回队列尾元素的值，但不删除该元素  
q.front()               返回队首元素的值，但不删除该元素
q.pop()                 删除队列首元素但不返回其值   
q.push()                在队尾压入新元素  

//vector
vec.size()
vec.push_back(1)       后面添加
vec.pop_back();        删除最后的元素 
vec.insert(vec.begin()+2,1)          在位置插入
vec.erase()           删除
vec.clear()           清除

reverse(v1.begin(),v1.end());  //翻转  使用reverse将元素翻转：需要头文件#include<algorithm> 

```

## array

## deque

std::deque（双向队列）是一个索引序列的容器，允许对其头部和尾部进行快速的插入和删除。此外，在deque两端插入和删除并不会使其它元素的指针或引用失效
```
std::deque<int> d = {7, 5, 16, 8};
size 
front 
back
insert 
erase 

push_back
pop_back 
push_front 
pop_front 


for(int n : d) {
        std::cout << n << '\n';
    }
```


## list

```
#include <list>
list<int> mylist;
int a=mylist.front();
int b=mylist.back();
size()
push_front()
pop_front()
push_back()
pop_back()
insert()
erase()
clear()
```


## set

set集合容器：实现了红黑树的平衡二叉检索树的数据结构，插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，以保证每个子树根节点键值大于左子树所有节点的键值，小于右子树所有节点的键值；另外，还得保证根节点左子树的高度与右子树高度相等。  
平衡二叉检索树使用中序遍历算法，检索效率高于vector、deque和list等容器，另外使用中序遍历可将键值按照从小到大遍历出来。  
构造set集合主要目的是为了快速检索，不可直接去修改键值。 

```
#include<set>
set<int> s;
set<int>:: iterator it;
s.insert(1);
s.insert(3);
s.insert(4);
for(it=s.begin();it!=s.end();it++)
{
	cout<<*it<<endl;
}


```

## Map

```
#include <map>
map<int,string> m ;
插入元素
改变map中的条目非常简单，因为map类已经对[]操作符进行了重载


map<int,char> m;
map<int,char >::iterator it;	
m[1]='a';
m[2]='b';
it=m.find(1);
cout<<it->first<<" "<<endl;
cout<<it->second<<endl;
cout<<m.find(1)->second <<endl;

```

## String


```
size
length
clear
empty

//第一次出现的位置
find Find content in string (public member function )
string str ("two needles in needles.");
string str2 ("needle");
    int found=str.find(str2);
cout<<found<<endl;
found=str.find(str2,found+1);
cout<<found<<endl;
found=str.find(str2,found+1);
cout<<found<<endl;
/*结果
4
15
-1
*/
rfind 最后一次出现的位置
find_first_of
Find character in string (public member function )
find_last_of
Find character in string from the end (public member function )
find_first_not_of
Find absence of character in string (public member function )
find_last_not_of
Find non-matching character in string from the end (public member function )

- 得到子串
substr Generate substring (public member function )

std::string str="We think in generalities, but we live in details.";
    //substr (起始位置,长度)
    std::string str2 = str.substr (3,5);     // "think"
    std::size_t pos = str.find("live");      // position of "live" in str
    std::string str3 = str.substr (pos);     // get from "live" to the end
    std::cout << str2 << ' ' << str3 << '\n';





```

## 传递二维数组

[ C/C++语言二维数组的传参方法总结](http://blog.csdn.net/gqb_driver/article/details/8886687)

- 方法一：形参为二维数组并给定第二维长度

```
#include <stdio.h>

void subfun(int n, char subargs[][5])
{
    int i;
    for (i = 0; i < n; i++) {
    	printf("subargs[%d] = %s\n", i, subargs[i]);
    }
}

void main()
{
    char args[][5] = {"abc", "def", "ghi"};
    subfun(3, args);
}
```
- 方法二：形参为指向数组的指针并给出数组长度

```
#include <stdio.h>

void subfun(int n, char (*subargs)[5])
{
    int i;
    for (i = 0; i < n; i++) {
    	printf("subargs[%d] = %s\n", i, subargs[i]);
    }
}

void main()
{
    char args[][5] = {"abc", "cde", "ghi"};
    subfun(3, args);
}
```

- 方法三：形参为指针的指针

此方法实参必须为指针，而不能为数组名

```

int m=5;
	int n=5;
	int ** arr=new int *[5];
	for(int i = 0; i < m; i++)
		arr[i] = new int[n];


		
#include <stdio.h>

void subfun(int n, char **subargs)
{
    int i; 
    for (i = 0; i < n; i++) {
    	printf("subargs[%d] = %s\n", i, subargs[i]);
    }
}

void main()
{
    char *a[3];
    char args[][5] = {"abc", "def", "ghi"};
    a[0] = args[0];  //equals with a[0] = &args[0][0];
    a[1] = args[1];
    a[2] = args[2];
    subfun(3, a);  //若此处为subfun(3, args);则会编译出错
}
```


# C语言

- malloc

```
#include <stdlib.h>

char * str = (char *) malloc(15);

free(str);  // 释放内存空间
```