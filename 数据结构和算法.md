# 数据结构和算法


## 字符串匹配

字符串查找算法中，最著名的两个是KMP算法（Knuth-Morris-Pratt)和BM算法（Boyer-Moore)。两个算法在最坏情况下均具有线性的查找时间。但是在实用上，KMP算法并不比最简单的c库函数strstr()快多少，

KMP并不是效率最高的算法，实际采用并不多。各种文本编辑器的"查找"功能（Ctrl+F），大多采用Boyer-Moore算法。BM算法则往往比KMP算法快上3－5倍。


但是BM算法还不是最快的算法，这里介绍一种比BM算法更快一些的查找算法---Sunday算法。


## KMP算法

[从头到尾彻底理解KMP](http://blog.csdn.net/v_july_v/article/details/7041827)

时间复杂度 O(m+n)

```

/*
字符串匹配算法
KMP

*/

#include<iostream>
#include<string>
using namespace std;

int * nextArr;
void genNext(string P)
{
	nextArr[0]=-1;
	int k=-1;
	int j=0;
	while( j<P.length()-1 )
	{
		if (k==-1 || P[k]==P[j])
		{
			k++;
			j++;
			nextArr[j]=k;
		}else
		{
			k=nextArr[k];
		}
	}

}

int  KMP(string S,string P)
{
	genNext(P);
	int l1=S.length();
	int l2=P.length();
	int i=0,j=0;

	while(i<l1 && j<l2)
	{

		if (j==-1  || S[i]==P[j])
		{
			i++;
			j++;
		} 
		else
		{
			j=nextArr[j];
		}
	}
	if(j==l2)
	{
		return i-l2;
	}else
	{
		return -1;
	}
}
int main()
{
	string S="BBC ABCDAB ABCDABCDABD";
	string P="ABCDABD";
	nextArr=new int[P.length()];
	cout<<KMP(S,P)<<endl;
	return 1;
}
```
## BM算法

- 坏字符（bad character）规则:

后移位数 = 坏字符的位置 - 索词中的上一次出现位置

(如果"坏字符"不包含在搜索词之中，则上一次出现位置为 -1。)

- 好后缀规则

后移位数 = 好后缀的位置 - 索词中的上一次出现位置

```
　（1）"好后缀"的位置以最后一个字符为准。假定"ABCDEF"的"EF"是好后缀，则它的位置以"F"为准，即5（从0开始计算）。
　　（2）如果"好后缀"在搜索词中只出现一次，则它的上一次出现位置为 -1。比如，"EF"在"ABCDEF"之中只出现一次，则它的上一次出现位置为-1（即未出现）。
　　（3）如果"好后缀"有多个，则除了最长的那个"好后缀"，其他"好后缀"的上一次出现位置必须在头部。比如，假定"BABCDAB"的"好后缀"是"DAB"、"AB"、"B"，请问这时"好后缀"的上一次出现位置是什么？回答是，此时采用的好后缀是"B"，它的上一次出现位置是头部，即第0位。这个规则也可以这样表达：如果最长的那个"好后缀"只出现一次，则可以把搜索词改写成如下形式进行位置计算"(DA)BABCDAB"，即虚拟加入最前面的"DA"。
```

非常清楚的讲解
[字符串匹配的Boyer-Moore算法](http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html)

- 代码实现

[算法代码](http://www.cnblogs.com/lanxuezaipiao/p/3452579.html)



## Sunday算法

[扩展2：Sunday算法](http://blog.csdn.net/v_JULY_v/article/details/7041827#t17)

我们已经介绍了KMP算法和BM算法，这两个算法在最坏情况下均具有线性的查找时间。但实际上，KMP算法并不比最简单的c库函数strstr()快多少，而BM算法虽然通常比KMP算法快，但BM算法也还不是现有字符串查找算法中最快的算法，本文最后再介绍一种比BM算法更快的查找算法即Sunday算法。

Sunday算法由Daniel M.Sunday在1990年提出，它的思想跟BM算法很相似：


只不过Sunday算法是从前往后匹配，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符。
如果该字符没有在模式串中出现则直接跳过，即移动位数 = 匹配串长度 + 1；
否则，其移动位数 = 模式串中最右端的该字符到末尾的距离+1。
    下面举个例子说明下Sunday算法。假定现在要在文本串"substring searching algorithm"中查找模式串"search"。

    1. 刚开始时，把模式串与文本串左边对齐：

substring searching algorithm
search
^
    2. 结果发现在第2个字符处发现不匹配，不匹配时关注文本串中参加匹配的最末位字符的下一位字符，即标粗的字符 i，因为模式串search中并不存在i，所以模式串直接跳过一大片，向右移动位数 = 匹配串长度 + 1 = 6 + 1 = 7，从 i 之后的那个字符（即字符n）开始下一步的匹配，如下图：

substring searching algorithm
　　　 search
　　　 ^
    3. 结果第一个字符就不匹配，再看文本串中参加匹配的最末位字符的下一位字符，是'r'，它出现在模式串中的倒数第3位，于是把模式串向右移动3位（r 到模式串末尾的距离 + 1 = 2 + 1 =3），使两个'r'对齐，如下：
substring searching algorithm
　　　　  search
　　　　　　 ^

    4. 匹配成功。

## 主要数据结构

线性表  堆栈与队列  字符串   树与二叉树 图 字典(检索结构)

主要算法

1. Greedy (贪心法)：最短路经
1. Divide & Conquer (分治法)：如二分法检索、Hanoi塔
1. Backtracking (回溯法)：迷宫、皇后问题
1. Dynamic programming (动态规划法)：优化问题
1. Local searching (局部搜索法)：最优化问题
1. Branch & limitation (分支限界法)：检索

# 2线性表

# 3 栈和队列

- Infix expression calculator (中缀表达式计算器)
- Reverse Poland calculator (逆波兰计算器)
- Conversion of the arithmetic expression (表达式转换)

进制转换
```
	int N=1348;
	int M=8;
	stack<int> st;
		while (N/M )
	{
		st.push(N%M);
		N=N/M;
	}
	st.push(N);
```

限于二元运算符的表达式定义:
表达式 ::= (操作数) + (算符) + (操作数)
操作数 ::=常量|变量 | 常数
算符 ::= 运算符(分为算术运算符、关系运算符和逻辑运算符) | 界限符(左右括号和表达式结束符   
Exp = S1 + OP + S2
前缀表示法 OP + S1 + S2
中缀表示法 S1 + OP + S2
后缀表示法 S1 + S2 + OP


例如:	Exp=a*b+(c-d/e)*f
前缀式:		+*ab*-c/def
中缀式:		a*b+c-d/e*f
后缀式:		ab*cde/-f*+   

- 中缀计算

为实现算符优先算法，在这里用了两个工作栈。一个存放算符OPTR，另一个存放数据OPND。算法思想是：
首先置数据栈为空栈，表达式起始符“＃”为算符栈的栈底元素
自左向右扫描表达式，读到操作数进OPND栈，读到运算符，则和OPTR栈顶元素比较（栈顶元素为c1，读到的算符为c2);
若c1<c2,则c2进栈继续扫描后面表达式；
若c1＝c2,则（“＝”），即括号内运算结束，将c1出栈，并且c2放弃,继续扫描后面表达式；
若c1>c2,则将c1出栈，并在操作数栈取出两个元素a和b按c1做运算，运算结果进OPND.
重复直到表达式求值完毕。

- 后缀表达式求值

先找运算符，再找操作数
在后缀表达式的计算顺序中已经隐含了加括号的优先次序，因而括号在后缀表达式中不出现。

遇到操作符,取出操作数计算结果入栈.

- 表达式中缀转后缀

```
#a+b*(c-d)-e/f#	 -->	abcd-*+ef/-

isp (in stack priority): the priority of operator at the top of OPTR stack.
icp (incoming priority): the new incoming operator priority.
If isp < icp, push the incoming operator into OPTR 
If isp > icp, output and pop the top of OPTR
If isp = icp, scan next item and pop the top of OPTR

```


- 背包问题

Baggage Loading (背包问题)
一个背包可以放入的物品重量T，现有n件物品，重量分别为w1,w2,…,wn，问能否从这些物品中选若干件放入背包中，使得放入的重量之和正好是T。


```

/*
description:背包问题的递归解法
输入：
输出：
author: jz 
email：zjhua678@163.com
Date: 20140818
*/
#include<stdio.h>
#include<stdlib.h>
#include<stack>
#include<queue>
#include <iostream>
using namespace  std;
int w[10]={1,2,3,4,5,6,7,8,9,10};
int knap(int t, int n)
{
	if ( t==0)
		return 1;
	else if (t<0 || t>0 && n<1)
		return 0;
	else if (knap(t-w[n-1], n-1) == 1)
	{
		printf ("result:n=%d,w[%d]=%d\n", n, n-1, w[n-1]);
		return 1;
	}
	else
		return (knap(t, n-1));
}

void main()
{
	printf("背包问题的递归解法\n");
	knap(15,10);
	printf("\n");
}
```

使用栈模拟队列


## 树和二叉树


## 查找检索排序