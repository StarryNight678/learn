# 数据结构和算法


## 字符串匹配

字符串查找算法中，最著名的两个是KMP算法（Knuth-Morris-Pratt)和BM算法（Boyer-Moore)。两个算法在最坏情况下均具有线性的查找时间。但是在实用上，KMP算法并不比最简单的c库函数strstr()快多少，

KMP并不是效率最高的算法，实际采用并不多。各种文本编辑器的"查找"功能（Ctrl+F），大多采用Boyer-Moore算法。BM算法则往往比KMP算法快上3－5倍。


但是BM算法还不是最快的算法，这里介绍一种比BM算法更快一些的查找算法---Sunday算法。


## KMP算法

[从头到尾彻底理解KMP](http://blog.csdn.net/v_july_v/article/details/7041827)

时间复杂度 O(m+n)

```

/*
字符串匹配算法
KMP

*/

#include<iostream>
#include<string>
using namespace std;

int * nextArr;
void genNext(string P)
{
	nextArr[0]=-1;
	int k=-1;
	int j=0;
	while( j<P.length()-1 )
	{
		if (k==-1 || P[k]==P[j])
		{
			k++;
			j++;
			nextArr[j]=k;
		}else
		{
			k=nextArr[k];
		}
	}

}

int  KMP(string S,string P)
{
	genNext(P);
	int l1=S.length();
	int l2=P.length();
	int i=0,j=0;

	while(i<l1 && j<l2)
	{

		if (j==-1  || S[i]==P[j])
		{
			i++;
			j++;
		} 
		else
		{
			j=nextArr[j];
		}
	}
	if(j==l2)
	{
		return i-l2;
	}else
	{
		return -1;
	}
}
int main()
{
	string S="BBC ABCDAB ABCDABCDABD";
	string P="ABCDABD";
	nextArr=new int[P.length()];
	cout<<KMP(S,P)<<endl;
	return 1;
}
```
## BM算法

- 坏字符（bad character）规则:

后移位数 = 坏字符的位置 - 索词中的上一次出现位置

(如果"坏字符"不包含在搜索词之中，则上一次出现位置为 -1。)

- 好后缀规则

后移位数 = 好后缀的位置 - 索词中的上一次出现位置

```
　（1）"好后缀"的位置以最后一个字符为准。假定"ABCDEF"的"EF"是好后缀，则它的位置以"F"为准，即5（从0开始计算）。
　　（2）如果"好后缀"在搜索词中只出现一次，则它的上一次出现位置为 -1。比如，"EF"在"ABCDEF"之中只出现一次，则它的上一次出现位置为-1（即未出现）。
　　（3）如果"好后缀"有多个，则除了最长的那个"好后缀"，其他"好后缀"的上一次出现位置必须在头部。比如，假定"BABCDAB"的"好后缀"是"DAB"、"AB"、"B"，请问这时"好后缀"的上一次出现位置是什么？回答是，此时采用的好后缀是"B"，它的上一次出现位置是头部，即第0位。这个规则也可以这样表达：如果最长的那个"好后缀"只出现一次，则可以把搜索词改写成如下形式进行位置计算"(DA)BABCDAB"，即虚拟加入最前面的"DA"。
```

非常清楚的讲解
[字符串匹配的Boyer-Moore算法](http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html)



## Sunday算法

[扩展2：Sunday算法](http://blog.csdn.net/v_JULY_v/article/details/7041827#t17)

我们已经介绍了KMP算法和BM算法，这两个算法在最坏情况下均具有线性的查找时间。但实际上，KMP算法并不比最简单的c库函数strstr()快多少，而BM算法虽然通常比KMP算法快，但BM算法也还不是现有字符串查找算法中最快的算法，本文最后再介绍一种比BM算法更快的查找算法即Sunday算法。

Sunday算法由Daniel M.Sunday在1990年提出，它的思想跟BM算法很相似：

只不过Sunday算法是从前往后匹配，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符。
如果该字符没有在模式串中出现则直接跳过，即移动位数 = 匹配串长度 + 1；
否则，其移动位数 = 模式串中最右端的该字符到末尾的距离+1。
    下面举个例子说明下Sunday算法。假定现在要在文本串"substring searching algorithm"中查找模式串"search"。

    1. 刚开始时，把模式串与文本串左边对齐：

substring searching algorithm
search
^
    2. 结果发现在第2个字符处发现不匹配，不匹配时关注文本串中参加匹配的最末位字符的下一位字符，即标粗的字符 i，因为模式串search中并不存在i，所以模式串直接跳过一大片，向右移动位数 = 匹配串长度 + 1 = 6 + 1 = 7，从 i 之后的那个字符（即字符n）开始下一步的匹配，如下图：

substring searching algorithm
　　　 search
　　　 ^
    3. 结果第一个字符就不匹配，再看文本串中参加匹配的最末位字符的下一位字符，是'r'，它出现在模式串中的倒数第3位，于是把模式串向右移动3位（r 到模式串末尾的距离 + 1 = 2 + 1 =3），使两个'r'对齐，如下：
substring searching algorithm
　　　　  search
　　　　　　 ^

    4. 匹配成功。